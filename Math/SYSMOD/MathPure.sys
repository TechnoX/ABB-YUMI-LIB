%%%
    VERSION:1
    LANGUAGE:ENGLISH
%%%

MODULE MathPure(SYSMODULE,NOVIEW)

    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: Min                                      *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the smallest of two arguments     *
    !*                                                        *
    !* IN:           Two num arguments                        *
    !*                                                        *
    !* RETURN:       num: The smallest passed number          *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num Min(
      num a,
      num b)
        IF a<b THEN
            RETURN a;
        ELSE
            RETURN b;
        ENDIF
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: Mean                                     *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the mean of an array              *
    !*                                                        *
    !* IN:           A num array                              *
    !*                                                        *
    !* RETURN:       num: The mean value of the array         *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num Mean(num a{*})
        VAR num sum;
        FOR i FROM 1 TO Dim(a,1) DO
            sum:=sum+a{i};
        ENDFOR
        RETURN sum/Dim(a,1);
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: NormDnum                                 *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the L2 norm of an array           *
    !*                                                        *
    !* IN:           A dnum array                             *
    !*                                                        *
    !* RETURN:       num: The L2 norm (euclidian length) of   *
    !*                    the array                           *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC dnum NormDnum(dnum a{*})
        VAR dnum sum;
        FOR i FROM 1 TO Dim(a,1) DO
            sum:=sum+a{i}*a{i};
        ENDFOR
        RETURN SqrtDnum(sum);
    ENDFUNC

    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: Max                                      *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the largest of two arguments      *
    !*                                                        *
    !* IN:           Two num arguments                        *
    !*                                                        *
    !* RETURN:       num: The largest passed number           *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num Max(
      num a,
      num b)
        IF a>b THEN
            RETURN a;
        ELSE
            RETURN b;
        ENDIF
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MaxDnum                                  *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the largest of two arguments      *
    !*                                                        *
    !* IN:           Two dnum arguments                       *
    !*                                                        *
    !* RETURN:       num: The largest passed number           *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC dnum MaxDnum(
      dnum a,
      dnum b)
        IF a>b THEN
            RETURN a;
        ELSE
            RETURN b;
        ENDIF
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MaxArray                                 *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the largest value in an array     *
    !*                                                        *
    !* IN:           A num array                              *
    !*                                                        *
    !* INOUT:        idx that will contain the index of the   *
    !*               largest element in the array             *
    !*                                                        *
    !* RETURN:       The largest value of the array           *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num MaxArray(num a{*},\num idx)
        VAR num max;
        max:=a{1};
        IF present(idx)
				idx:=1;
        FOR i FROM 2 TO Dim(a,1) DO
            IF a{i}>max THEN
                max:=a{i};
                IF present(idx) idx:=i;
            ENDIF
        ENDFOR
        RETURN max;
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MinArray                                 *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the smallest value in an array    *
    !*                                                        *
    !* IN:           A num array                              *
    !*                                                        *
    !* INOUT:        idx that will contain the index of the   *
    !*               smallest element in the array            *
    !*                                                        *
    !* RETURN:       The smallest value of the array          *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num MinArray(num a{*},\VAR num idx)
        VAR num min;
        min:=a{1};
        IF present(idx)
				idx:=1;
        FOR i FROM 2 TO Dim(a,1) DO
            IF a{i}<min THEN
                min:=a{i};
                IF present(idx)
				idx:=i;
            ENDIF
        ENDFOR
        RETURN min;
    ENDFUNC


    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: CrossProduct                             *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the vector cross product of the   *
    !*               two arguments a and b,   a x b           *
    !*                                                        *
    !* IN:           two 3D positions                         *
    !*                                                        *
    !* RETURN:       The cross product as a position          *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pos CrossProduct(
      pos a,
      pos b)
        VAR pos retpos;

        retpos.x:=a.y*b.z-a.z*b.y;
        retpos.y:=a.z*b.x-a.x*b.z;
        retpos.z:=a.x*b.y-a.y*b.x;
        RETURN retpos;
    ENDFUNC

    
    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: DotProductDnum                           *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Return the dot product of the two        *
    !*               arguments a and b.                       *
    !*                                                        *
    !* IN:           two dnum arrays                          *
    !*                                                        *
    !* RETURN:       The dot product as a dnum                *
    !*                                                        *
    !* NOTE:         a and b should have same dimension       *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC dnum DotProductDnum(
      dnum a{*},
      dnum b{*})
        VAR dnum sum;
        FOR i FROM 1 TO Dim(a,1) DO
            sum:=sum+a{i}*b{i};
        ENDFOR
        RETURN sum;
    ENDFUNC


    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: PoseToScrew                              *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Convert a pose (with quaternion) to a pos*
    !*               where the pos indicates the axis of      *
    !*               of rotation.                             *
    !*                                                        *
    !* IN:           pose P: to be converted.                 *
    !*                                                        *
    !* INOUT:        pos s0: Unknown ... (full screw params)  *
    !*               num t:  Unknown ...                      *
    !*               num theta: The total angle it is rotated *
    !*                                                        *
    !* RETURN:       The axis of rotation                     *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pos PoseToScrew(
      pose P,
      \VAR pos s0,
      \VAR num t,
      \VAR num theta)

        VAR pos s;
        VAR num mAngle;
        VAR num sinAngle;
        VAR num mt;
        VAR dnum A{3,3};
        VAR dnum b{3};
        VAR dnum x{3};
        VAR num tA{4,4};
        VAR bool status;

        mangle:=2*acos(P.rot.q1);
        sinAngle:=sin(mangle/2);
        IF abs(sinAngle)<1e-5 THEN
            s.z:=1;
        ELSE
            s.x:=P.rot.q2/sinAngle;
            s.y:=P.rot.q3/sinAngle;
            s.z:=P.rot.q4/sinAngle;
        ENDIF
        IF PRESENT(theta) THEN
            theta:=mangle;
        ENDIF
        mt:=DotProd(P.trans,s);
        IF PRESENT(t) THEN
            t:=mt;
        ENDIF
        IF PRESENT(s0) THEN
            posetoxform P,tA;
            A:=[[numtodnum(tA{1,1}-1),numtodnum(tA{1,2}),numtodnum(tA{1,3})],
            [numtodnum(tA{2,1}),numtodnum(tA{2,2}-1),numtodnum(tA{2,3})],
            [numtodnum(s.x),numtodnum(s.y),numtodnum(s.z)]];
            b:=[numtodnum(mt*s.x-tA{1,4}),
            numtodnum(mt*s.y-tA{2,4}),
            1];
            !status:=solve_gauss(A,b,3,x);
            MatrixSolve A\A_m:=3\A_n:=3,b,x;
            s0.x:=DnumTonum(x{1});
            s0.y:=DnumTonum(x{2});
            s0.z:=DnumTonum(x{3});
        ENDIF
        RETURN s;
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: ScrewToPose                              *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Returns the pose calculated from         *
    !*               screw parameters s,s0,t,theta            *
    !*                                                        *
    !* IN:           pos s: screw axis direction              *
    !*               pos s0: point on screw axis              *
    !*               num t: translation along screw axis      *
    !*               num theta: rotation about screw axis     *
    !*                                                        *
    !* RETURN:       The calculated pose record               *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pose ScrewToPose(pos s,pos s0,num t,num theta)
        VAR pose retpos;
        VAR num sinA;
        VAR num P{4,4};

        sinA:=sin(theta/2);
        retpos.rot.q1:=cos(theta/2);
        retpos.rot.q2:=s.x*sinA;
        retpos.rot.q3:=s.y*sinA;
        retpos.rot.q4:=s.z*sinA;
        posetoxform retpos,P;
        retpos.trans.x:=t*s.x-s0.x*(P{1,1}-1)-s0.y*P{1,2}-s0.z*P{1,3};
        retpos.trans.y:=t*s.y-s0.x*P{2,1}-s0.y*(P{2,2}-1)-s0.z*P{2,3};
        retpos.trans.z:=t*s.z-s0.x*P{3,1}-s0.y*P{3,2}-s0.z*(P{3,3}-1);
        RETURN retpos;
    ENDFUNC



    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: QuatRotAxis                              *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Calculates the rotation axis and         *
    !*               rotation angle of quaternion             *
    !*                                                        *
    !* IN:           orient q: the quaternion                 *
    !*                                                        *
    !* INOUT:        num angle: the rotated angle             *
    !*                                                        *
    !* RETURN:       The axis of rotation                     *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pos QuatRotAxis(orient q,\VAR num angle)
        !Return the rotation axis and rotation angle of q
        VAR pos retpos;
        VAR num mAngle;
        VAR num sinAngle;

        mangle:=2*acos(q.q1);
        IF PRESENT(angle) THEN
            angle:=mangle;
        ENDIF
        sinAngle:=sin(mangle/2);
        IF abs(sinAngle)<1e-5 THEN
            retpos.z:=1;
        ELSE
            retpos.x:=q.q2/sinAngle;
            retpos.y:=q.q3/sinAngle;
            retpos.z:=q.q4/sinAngle;
        ENDIF
        RETURN retpos;
    ENDFUNC
    
    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: AxisAngletoQuat                          *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Calculates the quaternion from           *
    !*               axis-angle representation                *
    !*                                                        *
    !* IN:           pos axis: the rotation axis              *
    !*               num angle: the rotated angle             *
    !*                                                        *
    !* RETURN:       orient: The quaternion                   *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC orient AxisAngletoQuat(pos axis,num angle)
        VAR pos nAxis;
        VAR num s;
        nAxis:=NormalizePos(axis);
        s:=sin(angle/2);
        RETURN [cos(angle/2),nAxis.x*s,nAxis.y*s,nAxis.z*s];
    ENDFUNC
    

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: NormalizePos                             *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Normalize a position/vector to length 1  *
    !*                                                        *
    !* IN:           pos a: The position to be normalized     *
    !*                                                        *
    !* RETURN:       pos: The normalized position/vector      *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pos NormalizePos(pos a)
        VAR pos retpos;
        VAR num norm;
        norm:=sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
        retpos.x:=a.x/norm;
        retpos.y:=a.y/norm;
        retpos.z:=a.z/norm;
        RETURN retpos;
    ENDFUNC


    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: Vec2Quat                                 *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Creates a quaternion from a 3x3 rotation *
    !*               matrix.                                  *
    !*                                                        *
    !* IN:           pos v1: first  column vector             *
    !*               pos v2: second column vector             *
    !*               pos v3: third  column vector             *
    !*                                                        *
    !* RETURN:       pos: The quaternion representing same    *
    !*                    rotation                            *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC orient Vec2Quat(pos v1,pos v2,pos v3)

        VAR orient q;
        VAR num traceR;
        VAR num rootv;
        VAR num u0;
        VAR num u1;
        VAR num u2;
        VAR num u3;

        traceR:=v1.x+v2.y+v3.z;
        IF traceR>0 THEN
            rootv:=sqrt(traceR+1.0);
            u0:=0.5*rootv;
            rootv:=0.5/rootv;
            u1:=(v2.z-v3.y)*rootv;
            u2:=(v3.x-v1.z)*rootv;
            u3:=(v1.y-v2.x)*rootv;
        ELSEIF (v1.x>=v2.y) AND (v1.x>=v3.z) THEN
            rootv:=sqrt(1.0+v1.x-(v2.y+v3.z));
            u1:=0.5*rootv;
            rootv:=0.5/rootv;
            u2:=(v2.x+v1.y)*rootv;
            u3:=(v1.z+v3.x)*rootv;
            u0:=(v2.z-v3.y)*rootv;
        ELSEIF (v2.y>=v3.z) THEN
            rootv:=sqrt(1.0+v2.y-(v3.z+v1.x));
            u2:=0.5*rootv;
            rootv:=0.5/rootv;
            u3:=(v3.y+v2.z)*rootv;
            u1:=(v2.x+v1.y)*rootv;
            u0:=(v3.x-v1.z)*rootv;
        ELSE
            rootv:=sqrt(1.0+v3.z-(v1.x+v2.y));
            u3:=0.5*rootv;
            rootv:=0.5/rootv;
            u1:=(v1.z+v3.x)*rootv;
            u2:=(v3.y+v2.z)*rootv;
            u0:=(v1.y-v2.x)*rootv;
        ENDIF
        q:=[u0,u1,u2,u3];
        q:=NOrient(q);
        IF q.q1<0 THEN
            q:=[-q.q1,-q.q2,-q.q3,-q.q4];
        ENDIF
        RETURN q;
    ENDFUNC


    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: InterpolatePose                          *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Interpolate linearly between two poses.  *
    !*               Will interpolate using a parameter       *
    !*                                                        *
    !* IN:           pose p1: First pose                      *
    !*               pose p2: Second pose                     *
    !*               num t: The ratio between p1 and p2.      *
    !*                      t=0 gives p1, t=1 gives p2        *
    !*                      t=0.5 gives the pose in the middle*
    !*                                                        *
    !* RETURN:       pose: The interpolated pose              *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pose InterpolatePose(pose p1,pose p2,num t)
        VAR num r;
        VAR num s;
        VAR num alpha;
        VAR num sinInv;
        VAR num lambda;
        VAR orient q1;
        VAR orient q2;
        VAR orient q;
        VAR bool flip;
        VAR pose retPose;


        !Interpolate the orientation
        q1:=p1.rot;
        q2:=p2.rot;
        !t:=(Angle-lowAngle)/(highAngle-lowAngle);
        lambda:=q1.q1*q2.q1+
                        q1.q2*q2.q2+
                        q1.q3*q2.q3+
                        q1.q4*q2.q4;
        r:=0.0;
        s:=0.0;
        flip:=FALSE;
        ! Use SLERP to interpolate between the quaternions */
        IF (lambda<0.0) THEN
            !
            ! * The quaternions are pointing in opposite directions, so
            ! * change sign to interpolate towards -q2 instead.
            ! */
            flip:=TRUE;
            lambda:=-lambda;
        ENDIF
        !/* The second condition is just to be safe from bad input quaternions */
        IF (abs(lambda-1.0)<0.0001 OR lambda>1.0) THEN
            ! /*
            !  * the quaternions are nearly parallel, so use
            !  * linear interpolation instead
            !  */
            r:=1.0-t;
            s:=t;
        ELSE
            !/* compute spherical interpolation factors */
            alpha:=acos(lambda);
            sinInv:=1.0/sin(alpha);
            r:=sin((1.0-t)*alpha)*sinInv;
            s:=sin(t*alpha)*sinInv;
        ENDIF
        IF (flip) THEN
            s:=-s;
        ENDIF
        !/* set the interpolated quaternion */
        q.q1:=r*q1.q1+s*q2.q1;
        q.q2:=r*q1.q2+s*q2.q2;
        q.q3:=r*q1.q3+s*q2.q3;
        q.q4:=r*q1.q4+s*q2.q4;
        !/* make sure u0 is positive */
        IF (q.q1<0.0) THEN
            q.q1:=-q.q1;
            q.q2:=-q.q2;
            q.q3:=-q.q3;
            q.q4:=-q.q4;
        ENDIF
        q:=NOrient(q);
        !Now calculate interpolated translation
        retPose.trans.x:=(p2.trans.x-p1.trans.x)*t+p1.trans.x;
        retPose.trans.y:=(p2.trans.y-p1.trans.y)*t+p1.trans.y;
        retPose.trans.z:=(p2.trans.z-p1.trans.z)*t+p1.trans.z;
        retPose.rot:=q;
        RETURN retPose;
    ENDFUNC

    
    
    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MatrixMultiply                           *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Multiply two num matrices                *
    !*                                                        *
    !* IN:           A: First matrix                          *
    !*               B: Second matrix                         *
    !*                                                        *
    !* INOUT:        res: The resulting product matrix        *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    PROC MatrixMultiply(num A{*,*},num B{*,*},VAR num res{*,*})
        VAR num sum;

        FOR i FROM 1 TO Dim(A,1) DO
            FOR j FROM 1 TO Dim(B,2) DO
                sum:=0;
                FOR n FROM 1 TO Dim(A,2) DO
                    sum:=sum+A{i,n}*B{n,j};
                ENDFOR
                res{i,j}:=sum;
            ENDFOR
        ENDFOR
    ENDPROC

    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MatrixTranspose                          *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Transpose a num matrix                   *
    !*                                                        *
    !* IN:           A: The matrix                            *
    !*                                                        *
    !* INOUT:        transpA: The resulting transposed matrix *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    PROC MatrixTranspose(num A{*,*},VAR num transpA{*,*})
        FOR i FROM 1 TO Dim(A,1) DO
            FOR j FROM 1 TO Dim(A,2) DO
                transpA{j,i}:=A{i,j};
            ENDFOR
        ENDFOR
    ENDPROC

    
    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MatrixTransposeDnum                      *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Transpose a dnum matrix                  *
    !*                                                        *
    !* IN:           A: The matrix                            *
    !*                                                        *
    !* INOUT:        transpA: The resulting transposed matrix *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    PROC MatrixTransposeDnum(dnum A{*,*},VAR dnum transpA{*,*})
        FOR i FROM 1 TO Dim(A,1) DO
            FOR j FROM 1 TO Dim(A,2) DO
                transpA{j,i}:=A{i,j};
            ENDFOR
        ENDFOR
    ENDPROC

    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: MatrixMultiply                           *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Multiply two dnum matrices               *
    !*                                                        *
    !* IN:           A: First matrix                          *
    !*               B: Second matrix                         *
    !*                                                        *
    !* INOUT:        res: The resulting product matrix        *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    PROC MatrixMultiplyDnum(dnum A{*,*},dnum B{*,*},VAR dnum res{*,*})
        VAR dnum sum;

        FOR i FROM 1 TO Dim(A,1) DO
            FOR j FROM 1 TO Dim(B,2) DO
                sum:=0;
                FOR n FROM 1 TO Dim(A,2) DO
                    sum:=sum+A{i,n}*B{n,j};
                ENDFOR
                res{i,j}:=sum;
            ENDFOR
        ENDFOR
        RETURN ;
    ENDPROC

    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: invert2DMatrix                           *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Invert a 2D matrix                       *
    !*                                                        *
    !* IN:           A: The 2D matrix                         *
    !*                                                        *
    !* INOUT:        invA: The inverted matrix                *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    PROC invert2DMatrix(num A{*,*},VAR num invA{*,*})
        VAR num det;

        det:=A{1,1}*A{2,2}-A{2,1}*A{1,2};
        invA{1,1}:=A{2,2}/det;
        invA{1,2}:=-A{1,2}/det;
        invA{2,2}:=A{1,1}/det;
        invA{2,1}:=-A{2,1}/det;
    ENDPROC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: invert3DMatrix                           *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Invert a 3D dnum matrix                  *
    !*                                                        *
    !* IN:           M: The 3D matrix                         *
    !*                                                        *
    !* INOUT:        res: The inverted matrix                 *
    !*                                                        *
    !* RETURN:       bool: Always true                        *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC bool invert3DMatrix(dnum M{*,*},VAR dnum res{*,*})
        VAR dnum det;
        VAR dnum a;
        VAR dnum b;
        VAR dnum c;
        VAR dnum d;
        VAR dnum e;
        VAR dnum f;
        VAR dnum g;
        VAR dnum h;
        VAR dnum k;
        a:=M{1,1};
        b:=M{1,2};
        c:=M{1,3};
        d:=M{2,1};
        e:=M{2,2};
        f:=M{2,3};
        g:=M{3,1};
        h:=M{3,2};
        k:=M{3,3};
        det:=a*(e*k-f*h)+b*(f*g-k*d)+c*(d*h-e*g);
        res:=[[(e*k-f*h)/det,(c*h-b*k)/det,(b*f-c*e)/det],
              [(f*g-d*k)/det,(a*k-c*g)/det,(c*d-a*f)/det],
              [(d*h-e*g)/det,(b*g-a*h)/det,(a*e-b*d)/det]];
        RETURN TRUE;
    ENDFUNC

    
    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: Modulo                                   *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Calculates a modulo b                    *
    !*                                                        *
    !* IN:           a: The numerator                         *
    !*               b: The denominator                       *
    !*                                                        *
    !* RETURN:       num: a modulo b                          *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num Modulo(num a,num b)
        VAR num dec;
        VAR num m;

        dec:=a-Trunc(a);
        m:=Trunc(a) MOD b;
        IF m<0 THEN
            m:=b+m+dec;
        ELSE
            m:=m+dec;
        ENDIF
        IF m>b THEN
            m:=m-b;
        ELSEIF m<0 THEN
            m:=b+m;
        ENDIF
        RETURN m;
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: SignDnum                                 *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Check whether u is negative or positive  *
    !*                                                        *
    !* IN:           u: The number to check                   *
    !*                                                        *
    !* RETURN:       dnum: -1 if negative, 1 otherwise        *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC dnum SignDnum(dnum u)
        IF u>=0 RETURN 1;
        RETURN -1;
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: Sign                                     *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Check whether u is negative or positive  *
    !*                                                        *
    !* IN:           u: The number to check                   *
    !*                                                        *
    !* RETURN:       num: -1 if negative, 1 otherwise         *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num Sign(num u)
        IF u>=0 RETURN 1;
        RETURN -1;
    ENDFUNC


    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: ComparePoses                             *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Check if PoseA and PoseB is equal up to  *
    !*               a certain tolerance                      *
    !*                                                        *
    !* IN:           PoseA: The first pose                    *
    !*               PoseB: The second pose                   *
    !*               posTolerance: The tolerance in position  *
    !*               angleTolerance: The angle tolerance      *   
    !*                                                        *
    !* RETURN:       Returns true if difference is within     *
    !*               tolerance and false otherwise            *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC bool ComparePoses(pose PoseA,pose PoseB,num posTolerance,num AngleTolerance)
        VAR pose poseDiff;
        VAR num transDiff;
        VAR num rotDiff;
        VAR pos rotAxis;
        PoseA.trans.z:=PoseB.trans.z;
        poseDiff:=PoseMult(PoseInv(PoseA),PoseB);
        transDiff:=VectMagn(poseDiff.trans);
        rotAxis:=QuatRotAxis(poseDiff.rot,\angle:=rotDiff);
        IF transDiff<posTolerance AND Abs(rotDiff)<AngleTolerance THEN
            RETURN TRUE;
        ELSE
            TPWrite "Pose difference outside tolerance in "+GetTaskName()+"/ComparePoses";
            TPWrite "Position Error = "+NumToStr(transDiff,3)+", Rotation Error = "+NumToStr(rotDiff,3);
            RETURN FALSE;
        ENDIF
    ENDFUNC

    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: CalcLSQPlane                             *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Calulates a best fit plane for points    *
    !*                                                        *
    !* IN:           robtarget array: Array of points         *
    !*                                                        *
    !* RETURN:       pose: The plane that fits all the input  *
    !*                     points best, according to LSQ.     *
    !*                                                        *
    !* NOTE:         Maximum of 10 points allowed as input    *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC pose CalcLSQPlane(robtarget points{*})
        VAR num N;
        VAR dnum A{10,3};
        VAR dnum b{10};
        VAR pose retPose;
        VAR dnum x{3};
        VAR pos planeNormal;
        VAR num D;
        VAR num Angle;
        VAR pos rotAxis;
        N:=Dim(points,1);
        IF N>10 THEN
            ErrWrite "Error in CalcLSQPlane","Maximum 10 points can be used";
            RETURN retPose;
        ENDIF
        !A=[points(:,2:3) ones(N,1)];
        !b=-points(:,1);
        FOR i FROM 1 TO N DO
            A{i,1}:=numtodnum(points{i}.trans.x);
            A{i,2}:=numtodnum(points{i}.trans.y);
            A{i,3}:=1;
            b{i}:=-numtodnum(points{i}.trans.z);
        ENDFOR

        MatrixSolve A\A_m:=N\A_n:=3,b,x;

        !n=[x(1:2)' 1];
        !plane=[x(1:2)' 1 x(3)]/norm(n);
        !plane normal points along positive z axis
        planeNormal:=[dnumtonum(x{1}),dnumtonum(x{2}),1];
        D:=dnumtonum(x{3});

        !place origin along z axis
        retPose.trans.x:=0;
        retPose.trans.y:=0;
        retPose.trans.z:=-D/planeNormal.z;
        !Calclate angle between z axis and plane normal
        planeNormal:=NormalizePos(planeNormal);
        Angle:=acos(DotProd(planeNormal,[0,0,1]));
        !calculate the rotation axis
        rotAxis:=CrossProduct([0,0,1],planeNormal);
        !Convert to quaternion
        retPose.rot:=NOrient(AxisAngletoQuat(rotAxis,Angle));
        RETURN retPose;
    ENDFUNC

        
    
    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: CalcOverTurn                             *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Makes the angle to be outside of the     *
    !*               range -180 to 180.                       *
    !*                                                        *
    !* IN:           angle: The angle to be constrained       *
    !*                                                        *
    !* RETURN:       num: An angle outside of -180 and 180    *
    !*                                                        *
    !* NOTE:         For example will   0 => -360             *
    !*                                 10 => -350             *
    !*                                170 => -190             *
    !*                                 -1 => 359              *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num CalcOverTurn(num angle)
        IF angle<0 AND angle>-180 THEN
            RETURN angle+360;
        ELSEIF angle>=0 AND angle<180 THEN
            RETURN angle-360;
        ELSE
            RETURN angle;
        ENDIF
    ENDFUNC

    !**********************************************************
    !*                                                        *
    !* ROUTINE NAME: CalcDistanceToPath                       *
    !*                                                        *
    !**********************************************************
    !*                                                        *
    !* DESCRIPTION:  Calculates the distance between p and    *
    !*               the path from l1 to l2                   *
    !*                                                        *
    !* IN:           l1: Start point of line                  *
    !*               l2: End point of line                    *
    !*               p: The point to calculate distance to    *
    !*                                                        *
    !* RETURN:       num: The closest distance between line   *
    !*                    and point p.                        *
    !*                                                        *
    !* NOTE:         If the orthogonal projection of p on     *
    !*               l1l2 lies on the path the distance to    *
    !*               the line is returned.                    *
    !*               If the projection lies outside the line  *
    !*               the distance to the closest point on the * 
    !*               l1l2 path is returned.                   *
    !*                                                        *
    !* EXAMPLE:      <example, how the routine is used        *
    !*               (only if this is not obvious)>           *
    !*                                                        *
    !*                                                        *
    !* Date:        Version:   Programmer:          Reason:   *
    !* 2016-07-15   1.0        Ivan Lundberg        created   *
    !**********************************************************
    FUNC num CalcDistanceToPath(pos l1,pos l2,pos p)
        VAR pos pDir_hat;
        VAR pos mPos;
        VAR pos mPos_hat;
        VAR num mPosNorm;
        VAR num l;
        pDir_hat:=NormalizePos(l2-l1);
        mPos:=p-l1;
        mPos_hat:=NormalizePos(mPos);
        mPosNorm:=VectMagn(mPos);
        l:=DotProd(l2-l1,p-l1)/VectMagn(l2-l1);
        IF l>VectMagn(l2-l1) THEN
            !TPWrite "After path";
            RETURN VectMagn(l2-p);
        ELSEIF l<0 THEN
            !TPWrite "Before path";
            RETURN VectMagn(l1-p);
        ELSE
            !TPWrite "On path";
            RETURN VectMagn(mPos-DotProd(pDir_hat,mPos_hat)*mPosNorm*pDir_hat);
        ENDIF
    ENDFUNC


ENDMODULE
